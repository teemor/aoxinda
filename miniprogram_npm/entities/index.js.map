{"version":3,"sources":["index.js","compile.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var compiled = require(\"./compile.js\"),\n    modes = [\"XML\", \"HTML4\", \"HTML5\"];\n\nvar levels = modes.map(function(name, i){\n\tvar obj = compiled[name],\n\t    strict = genReplaceFunc(obj.strict, getStrictReplacer(obj.obj)),\n\t    //there is no non-strict mode for XML\n\t    normal = i === 0 ? strict : genReplaceFunc(obj.normal, getReplacer(obj.obj)),\n\t    inverse = getInverse(obj.inverseObj, obj.inverse);\n\n\texports[\"decode\" + name + \"Strict\"] = strict;\n\texports[\"decode\" + name] = normal;\n\texports[\"encode\" + name] = inverse;\n\n\treturn {\n\t\tstrict:  strict,\n\t\tnormal:  normal,\n\t\tinverse: inverse\n\t};\n});\n\nvar decode = levels.map(function(l){ return l.normal; }),\n    decodeStrict = levels.map(function(l){ return l.strict; }),\n    encode = levels.map(function(l){ return l.inverse; });\n\nexports.decode = function(data, level){\n\tif(!(level >= 0 && level < 3)) level = 0;\n\treturn decode[level](data);\n};\nexports.decodeStrict = function(data, level){\n\tif(!(level >= 0 && level < 3)) level = 0;\n\treturn decodeStrict[level](data);\n};\nexports.encode = function(data, level){\n\tif(!(level >= 0 && level < 3)) level = 0;\n\treturn encode[level](data);\n};\n\nfunction getReplacer(obj){\n\treturn function normalReplacer(name){\n\t\tif(name.charAt(1) === \"#\"){\n\t\t\tif(name.charAt(2).toLowerCase() === \"x\"){\n\t\t\t\treturn codePointToSymbol(parseInt(name.substr(3), 16));\n\t\t\t}\n\t\t\treturn codePointToSymbol(parseInt(name.substr(2), 10));\n\t\t}\n\t\treturn obj[name.substr(1)];\n\t};\n}\n\nfunction codePointToSymbol(entity){\n\treturn String.fromCharCode(entity); //TODO\n}\n\nfunction getStrictReplacer(obj){\n\treturn function strictReplacer(name){\n\t\tif(name.charAt(1) === \"#\"){\n\t\t\tif(name.charAt(2).toLowerCase() === \"x\"){\n\t\t\t\treturn String.fromCharCode(parseInt(name.substr(3), 16));\n\t\t\t}\n\t\t\treturn String.fromCharCode(parseInt(name.substr(2), 10));\n\t\t}\n\t\treturn obj[name.substr(1)];\n\t};\n}\n\nvar re_nonASCII = /[^\\0-\\x7F]/g,\n    re_astralSymbols = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\nfunction nonUTF8Replacer(c){\n\treturn \"&#x\" + c.charCodeAt(0).toString(16).toUpperCase() + \";\";\n}\n\nfunction astralReplacer(c){\n\t// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\tvar high = c.charCodeAt(0);\n\tvar low  = c.charCodeAt(1);\n\tvar codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;\n\treturn \"&#x\" + codePoint.toString(16).toUpperCase() + \";\";\n}\n\nfunction getInverse(inverse, re){\n\tfunction func(name){\n\t\treturn \"&\" + inverse[name];\n\t}\n\n\treturn function(data){\n\t\treturn data\n\t\t\t\t.replace(re, func)\n\t\t\t\t.replace(re_astralSymbols, astralReplacer)\n\t\t\t\t.replace(re_nonASCII, nonUTF8Replacer);\n\t};\n}\n\nfunction genReplaceFunc(regex, func){\n\treturn function(data){\n\t\treturn data.replace(regex, func);\n\t};\n}\n","var modes = [\"XML\", \"HTML4\", \"HTML5\"];\n\nmodes.reduce(function(prev, name, i){\n\tvar obj = require(\"./entities/\" + name.toLowerCase() + \".json\");\n\n\tif(prev){\n\t\tObject.keys(prev).forEach(function(name){\n\t\t\tobj[name] = prev[name];\n\t\t});\n\t}\n\n\tvar inverse = getInverse(obj);\n\n\tmodule.exports[name] = {\n\t\tstrict: getStrictReplacer(obj),\n\t\t//there is no non-strict mode for XML\n\t\tnormal: i === 0 ? null : getReplacer(obj),\n\t\tinverse: getInverseReplacer(inverse),\n\t\tinverseObj: inverse,\n\t\tobj: obj\n\t};\n\n\treturn obj;\n}, null);\n\nfunction sortDesc(a, b){\n\treturn a < b ? 1 : -1;\n}\n\nfunction getReplacer(obj){\n\tvar keys = Object.keys(obj).sort(sortDesc);\n\tvar re = keys.join(\"|\")//.replace(/(\\w+);\\|\\1/g, \"$1;?\");\n\n\t// also match hex and char codes\n\tre += \"|#[xX][\\\\da-fA-F]+;?|#\\\\d+;?\";\n\n\treturn new RegExp(\"&(?:\" + re + \")\", \"g\");\n}\n\nfunction getStrictReplacer(obj){\n\tvar keys = Object.keys(obj).sort(sortDesc).filter(RegExp.prototype.test, /;$/);\n\tvar re = keys.map(function(name){\n\t\treturn name.slice(0, -1); //remove trailing semicolon\n\t}).join(\"|\");\n\n\t// also match hex and char codes\n\tre += \"|#[xX][\\\\da-fA-F]+|#\\\\d+\";\n\n\treturn new RegExp(\"&(?:\" + re + \");\", \"g\");\n}\n\nfunction getInverse(obj){\n\treturn Object.keys(obj).filter(function(name){\n\t\t//prefer identifiers with a semicolon\n\t\treturn name.substr(-1) === \";\" || obj[name + \";\"] !== obj[name];\n\t}).reduce(function(inverse, name){\n\t\tinverse[obj[name]] = name;\n\t\treturn inverse;\n\t}, {});\n}\n\nfunction getInverseReplacer(inverse){\n\treturn new RegExp(\"\\\\\" + Object.keys(inverse).sort().join(\"|\\\\\"), \"g\");\n}\n"]}