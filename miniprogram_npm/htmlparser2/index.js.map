{"version":3,"sources":["index.js","Parser.js","ElementType.js","FeedHandler.js","Stream.js","WritableStream.js","stream.js","ProxyHandler.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,AGTA,AJYA;AELA,ACHA,AFMA,AGTA,AJYA;AELA,ACHA,AFMA,AGTA,AJYA;AELA,ACHA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA,AMlBA;AHUA,AFMA,AGTA,ACHA,ALeA,AMlBA;AHUA,AFMA,AGTA,ACHA,ALeA,AMlBA;AHUA,AFMA,AMlBA,AHSA,ACHA,ALeA,AMlBA;AHUA,AFMA,AMlBA,AHSA,ACHA,ALeA,AMlBA;AHUA,AFMA,AMlBA,AHSA,ACHA,ALeA,AMlBA;AHUA,AFMA,AMlBA,AHSA,ACHA,ALeA,AMlBA;AHUA,AFMA,AMlBA,AHSA,ACHA,ALeA,AMlBA;AHUA,AFMA,AMlBA,AHSA,ACHA,ALeA,AMlBA;AHUA,AFMA,AMlBA,AHSA,ACHA,ALeA,AMlBA;AHUA,AFMA,AMlBA,AHSA,ACHA,ALeA,AMlBA;AHUA,AFMA,AMlBA,AHSA,ACHA,ALeA,AMlBA;AHUA,AFMA,AMlBA,AHSA,ACHA,ALeA,AMlBA;AHUA,AFMA,AMlBA,AHSA,ACHA,ALeA,AMlBA;AHUA,AFMA,AMlBA,AHSA,ACHA,ALeA,AMlBA;AHUA,AFMA,AMlBA,AHSA,ACHA,ALeA,AMlBA;AHUA,AFMA,AMlBA,AHSA,AJYA,AMlBA;AHUA,AFMA,AMlBA,AHSA,AJYA,AMlBA;AHUA,AFMA,AMlBA,AHSA,AJYA,AMlBA;AHUA,AFMA,AMlBA,AHSA,AJYA,AMlBA;AHUA,AFMA,AMlBA,AHSA,AJYA,AMlBA;AHUA,AFMA,AMlBA,AHSA,AJYA,AMlBA;AHUA,AFMA,AGTA,AJYA,AMlBA;AHUA,AFMA,AGTA,AJYA,AMlBA;AHUA,AFMA,AGTA,AJYA,AMlBA;AHUA,AFMA,AGTA,AJYA,AMlBA;AHUA,AFMA,AGTA,AJYA,AMlBA;AHUA,AFMA,AGTA,AJYA,AMlBA;AHUA,AFMA,AGTA,AJYA,AMlBA;AHUA,AFMA,ADGA,AMlBA;AHUA,AFMA,ADGA,AMlBA;AHUA,AFMA,ADGA,AMlBA;AHUA,AFMA,ADGA,AMlBA;AHUA,AFMA,ADGA,AMlBA;AHUA,AFMA,ADGA,AMlBA;AHUA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var defineProp = Object.defineProperty;\n\nmodule.exports = {\n\tget Parser(){\n\t\tdefineProp(this, \"Parser\", {value:require(\"./Parser.js\")});\n\t\treturn this.Parser;\n\t},\n\tget DomHandler(){\n\t\tdefineProp(this, \"DomHandler\", {value:require(\"domhandler\")});\n\t\treturn this.DomHandler;\n\t},\n\tget FeedHandler(){\n\t\tdefineProp(this, \"FeedHandler\", {value:require(\"./FeedHandler.js\")});\n\t\treturn this.FeedHandler;\n\t},\n\tget ElementType(){\n\t\tdefineProp(this, \"ElementType\", {value:require(\"domelementtype\")});\n\t\treturn this.ElementType;\n\t},\n\tget Stream(){\n\t\tdefineProp(this, \"Stream\", {value:require(\"./Stream.js\")});\n\t\treturn this.Stream;\n\t},\n\tget WritableStream(){\n\t\tdefineProp(this, \"WritableStream\", {value:require(\"./WritableStream.js\")});\n\t\treturn this.WritableStream;\n\t},\n\tget ProxyHandler(){\n\t\tdefineProp(this, \"ProxyHandler\", {value:require(\"./ProxyHandler.js\")});\n\t\treturn this.ProxyHandler;\n\t},\n\tget DomUtils(){\n\t\tdefineProp(this, \"DomUtils\", {value:require(\"domutils\")});\n\t\treturn this.DomUtils;\n\t},\n\t// For legacy support\n\tget DefaultHandler(){\n\t\tdefineProp(this, \"DefaultHandler\", {value: this.DomHandler});\n\t\treturn this.DefaultHandler;\n\t},\n\tget RssHandler(){\n\t\tdefineProp(this, \"RssHandler\", {value: this.FeedHandler});\n\t\treturn this.FeedHandler;\n\t},\n\t// List of all events that the parser emits\n\tEVENTS: { /* Format: eventname: number of arguments */\n\t\tattribute: 2,\n\t\tcdatastart: 0,\n\t\tcdataend: 0,\n\t\ttext: 1,\n\t\tprocessinginstruction: 2,\n\t\tcomment: 1,\n\t\tcommentend: 0,\n\t\tclosetag: 1,\n\t\topentag: 2,\n\t\topentagname: 1,\n\t\terror: 1,\n\t\tend: 0\n\t}\n}","var ElementType = require(\"./ElementType.js\");\n\nfunction Parser(cbs, options){\n\tthis._options = options || defaultOpts;\n\tthis._cbs = cbs || defaultCbs;\n\tthis._buffer = \"\";\n\tthis._tagSep = \">\";\n\tthis._stack = [];\n\tthis._wroteSpecial = false;\n\tthis._contentFlags = 0;\n\tthis._done = false;\n\tthis._running = true; //false if paused\n}\n\n//Regular expressions used for cleaning up and parsing (stateless)\n\n/* http://dev.w3.org/html5/html-author/#attributes\n * - Whitespace is permitted after the tag name, but it is not permitted before the tag name.\n * - Attribute names must consist of one or more characters other than the space characters,\n *   control characters, NULL, one of the characters: double quote (\"), single quote ('),\n *   greater-than sign (>), solidus (/), equals sign (=), nor any characters that are not defined by Unicode.\n * - An empty attribute is one where the value has been omitted. (<input disabled>...</input>\n * - An unquoted attribute value must not contain any literal space characters, any of the characters:\n *   double quote (\"), apostrophe ('), equals sign (=), less-than sign (<), greater-than sign (>),\n *   or grave accent (`), and the value must not be the empty string.\n * - There may be space characters between the attribute name and the equals sign (=),\n *   and between that and the attribute value.\n * - Double-quoted attributes must not contain any double-quote characters or ambiguous ampersands.\n * - Single-quoted attributes must not contain any single-quote characters or ambiguous ampersands.\n */\n// element name:\t(<[^<& ]+)\n// attribute name:\t( [^\"'=>\\/]+)\n// attribute value:\t(\\s*=\\s*(?:\n//\t\t\t\t\t\t\"([^\"]*)\"|\n//\t\t\t\t\t\t'([^']*)'|\n//\t\t\t\t\t\t[^\\s\"'=<>`]+)\n// tag end: (?=\\s|\\/|$)\n\nvar _reAttrib = /\\s+([^\"'=>\\/\\s]+)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"'=<>`]+))|(?=\\s)|\\/|$)/g,\n    _reTail = /\\s|\\/|$/;\n\nvar defaultOpts = {\n\txmlMode: false, //Special behavior for script/style tags by default\n\tlowerCaseAttributeNames: false, //call .toLowerCase for each attribute name\n\tlowerCaseTags: false //call .toLowerCase for each tag name\n};\n\nvar defaultCbs = {\n\t/*\n\t\tThis is just a plain object\n\t\tso that the parser doesn't\n\t\tthrow if no arguments were\n\t\tprovided.\n\t*/\n\t/*\n\t\toncdataend,\n\t\toncdatastart,\n\t\tonclosetag,\n\t\toncomment,\n\t\toncommentend,\n\t\tonerror,\n\t\tonopentag,\n\t\tonopentagend,\n\t\tonprocessinginstruction,\n\t\tonreset,\n\t\tontext\n\t*/\n};\n\nvar formTags = {\n\tinput: true,\n\toption: true,\n\toptgroup: true,\n\tselect: true,\n\tbutton: true,\n\tdatalist: true,\n\ttextarea: true\n};\nvar openImpliesClose = {\n\ttr      : { tr:true, th:true, td:true },\n\tth      : { th:true },\n\ttd      : { thead:true, td:true },\n\tbody    : { head:true, link:true, script:true },\n\tli      : { li:true },\n\tp       : { p:true },\n\tselect  : formTags,\n\tinput   : formTags,\n\toutput  : formTags,\n\tbutton  : formTags,\n\tdatalist: formTags,\n\ttextarea: formTags,\n\toption  : { option:true },\n\toptgroup: { optgroup:true }\n};\n\n//Parses a complete HTML and pushes it to the handler\nParser.prototype.parseComplete = function(data){\n\tthis.reset();\n\tthis.end(data);\n};\n\n//Parses a piece of an HTML document\nParser.prototype.parseChunk =\nParser.prototype.write = function(data){\n\tif(this._done) this._handleError(\"Attempted to parse chunk after parsing already done\");\n\tthis._buffer += data; //FIXME: this can be a bottleneck\n\tif(this._running) this._parseTags();\n};\n\n//Tells the parser that the HTML being parsed is complete\nParser.prototype.done =\nParser.prototype.end = function(chunk){\n\tif(this._done) return;\n\n\tif(chunk) this.write(chunk);\n\tthis._done = true;\n\t\n\tif(this._running) this._finishParsing();\n};\n\nParser.prototype._finishParsing = function(){\n\t//Parse the buffer to its end\n\tif(this._buffer) this._parseTags(true);\n\t\n\tif(this._cbs.onclosetag){\n\t\twhile(this._stack.length) this._cbs.onclosetag(this._stack.pop());\n\t}\n\t\n\tif(this._cbs.onend) this._cbs.onend();\n};\n\nParser.prototype.pause = function(){\n\tif(!this._done) this._running = false;\n};\n\nParser.prototype.resume = function(){\n\tif(this._running) return;\n\tthis._running = true;\n\tthis._parseTags();\n\tif(this._done) this._finishParsing();\n};\n\n//Resets the parser to a blank state, ready to parse a new HTML document\nParser.prototype.reset = function(){\n\tParser.call(this, this._cbs, this._options);\n\tif(this._cbs.onreset) this._cbs.onreset();\n};\n\n//Extracts the base tag name from the data value of an element\nParser.prototype._parseTagName = function(data){\n\tvar match = data.substr(0, data.search(_reTail));\n\tif(!this._options.lowerCaseTags) return match;\n\treturn match.toLowerCase();\n};\n\n//Special tags that are treated differently\nvar SpecialTags = {};\n//SpecialTags[ElementType.Tag]   = 0x0;\nSpecialTags[ElementType.Style]   = 0x1; //2^0\nSpecialTags[ElementType.Script]  = 0x2; //2^1\nSpecialTags[ElementType.Comment] = 0x4; //2^2\nSpecialTags[ElementType.CDATA]   = 0x8; //2^3\n\nvar TagValues = {\n\tstyle: 1,\n\tscript: 2\n};\n\n//Parses through HTML text and returns an array of found elements\nParser.prototype._parseTags = function(force){\n\tvar current = 0,\n\t    opening = this._buffer.indexOf(\"<\"),\n\t    closing = this._buffer.indexOf(\">\"),\n\t    next, rawData, elementData, lastTagSep;\n\n\t//if force is true, parse everything\n\tif(force) opening = Infinity;\n\n\t//opening !== closing is just false if both are -1\n\twhile(opening !== closing && this._running){\n\t\tlastTagSep = this._tagSep;\n\t\t\n\t\tif((opening !== -1 && opening < closing) || closing === -1){\n\t\t\tnext = opening;\n\t\t\tthis._tagSep = \"<\";\n\t\t\topening = this._buffer.indexOf(\"<\", next + 1);\n\t\t}\n\t\telse{\n\t\t\tnext = closing;\n\t\t\tthis._tagSep = \">\";\n\t\t\tclosing = this._buffer.indexOf(\">\", next + 1);\n\t\t}\n\t\trawData = this._buffer.substring(current, next); //The next chunk of data to parse\n\t\t\n\t\t//set elements for next run\n\t\tcurrent = next + 1;\n\t\t\n\t\tif(this._contentFlags >= SpecialTags[ElementType.CDATA]){\n\t\t\t// We're inside a CDATA section\n\t\t\tthis._writeCDATA(rawData);\n\n\t\t}\n\t\telse if(this._contentFlags >= SpecialTags[ElementType.Comment]){\n\t\t\t//We're in a comment tag\n\t\t\tthis._writeComment(rawData);\n\t\t}\n\t\telse if(lastTagSep === \"<\"){\n\t\t\telementData = rawData.trimLeft();\n\t\t\tif(elementData.charAt(0) === \"/\"){\n\t\t\t\t//elementData = elementData.substr(1).trim();\n\t\t\t\telementData = this._parseTagName(elementData.substr(1));\n\t\t\t\tif(this._contentFlags !== 0){\n\t\t\t\t\t//if it's a closing tag, remove the flag\n\t\t\t\t\tif(this._contentFlags & TagValues[elementData]){\n\t\t\t\t\t\t//remove the flag\n\t\t\t\t\t\tthis._contentFlags ^= TagValues[elementData];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._writeSpecial(rawData, lastTagSep);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._processCloseTag(elementData);\n\t\t\t}\n\t\t\telse if(this._contentFlags !== 0) this._writeSpecial(rawData, lastTagSep);\n\t\t\telse if(elementData.charAt(0) === \"!\"){\n\t\t\t\tif(elementData.substr(1, 7) === \"[CDATA[\"){\n\t\t\t\t\tthis._contentFlags |= SpecialTags[ElementType.CDATA];\n\t\t\t\t\tif(this._cbs.oncdatastart) this._cbs.oncdatastart();\n\t\t\t\t\tthis._writeCDATA(elementData.substr(8));\n\t\t\t\t}\n\t\t\t\telse if(this._contentFlags !== 0) this._writeSpecial(rawData, lastTagSep);\n\t\t\t\telse if(elementData.substr(1, 2) === \"--\"){\n\t\t\t\t\t//This tag is a comment\n\t\t\t\t\tthis._contentFlags |= SpecialTags[ElementType.Comment];\n\t\t\t\t\tthis._writeComment(rawData.substr(3));\n\t\t\t\t}\n\t\t\t\t//TODO: This isn't a processing instruction, needs a new name\n\t\t\t\telse if(this._cbs.onprocessinginstruction){\n\t\t\t\t\tthis._cbs.onprocessinginstruction(\n\t\t\t\t\t\t\"!\" + this._parseTagName(elementData.substr(1)),\n\t\t\t\t\t\telementData\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(elementData.charAt(0) === \"?\"){\n\t\t\t\tif(this._cbs.onprocessinginstruction){\n\t\t\t\t\tthis._cbs.onprocessinginstruction(\n\t\t\t\t\t\t\"?\" + this._parseTagName(elementData.substr(1)),\n\t\t\t\t\t\telementData\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse this._processOpenTag(elementData);\n\t\t}\n\t\telse{\n\t\t\tif(this._contentFlags !== 0){\n\t\t\t\tthis._writeSpecial(rawData, \">\");\n\t\t\t}\n\t\t\telse if(this._cbs.ontext){\n\t\t\t\tif(this._tagSep === \">\") rawData += \">\"; //it's the second > in a row\n\t\t\t\tif(rawData !== \"\") this._cbs.ontext(rawData);\n\t\t\t}\n\t\t}\n\t}\n\n\tthis._buffer = this._buffer.substr(current);\n};\n\nParser.prototype._writeCDATA = function(data){\n\tif(this._tagSep === \">\" && data.substr(-2) === \"]]\"){\n\t\t// CDATA ends\n\t\tif(data.length !== 2 && this._cbs.ontext){\n\t\t\tthis._cbs.ontext(data.slice(0,-2));\n\t\t}\n\t\tthis._contentFlags ^= SpecialTags[ElementType.CDATA];\n\t\tif(this._cbs.oncdataend) this._cbs.oncdataend();\n\t\tthis._wroteSpecial = false;\n    }\n    else if(this._cbs.ontext) this._cbs.ontext(data + this._tagSep);\n};\n\nParser.prototype._writeComment = function(rawData){\n\tif(this._tagSep === \">\" && rawData.substr(-2) === \"--\"){ //comment ends\n\t\t//remove the written flag (also removes the comment flag)\n\t\tthis._contentFlags ^= SpecialTags[ElementType.Comment];\n\t\tthis._wroteSpecial = false;\n\t\tif(this._cbs.oncomment) this._cbs.oncomment(rawData.slice(0, -2));\n\t\tif(this._cbs.oncommentend) this._cbs.oncommentend();\n\t}\n\telse if(this._cbs.oncomment) this._cbs.oncomment(rawData + this._tagSep);\n};\n\nParser.prototype._writeSpecial = function(rawData, lastTagSep){\n\t//if the previous element is text, append the last tag sep to element\n\tif(this._wroteSpecial){\n\t\tif(this._cbs.ontext) this._cbs.ontext(lastTagSep + rawData);\n\t}\n\telse{ //The previous element was not text\n\t\tthis._wroteSpecial = true;\n\t\tif(rawData !== \"\" && this._cbs.ontext) this._cbs.ontext(rawData);\n\t}\n};\n\nvar emptyTags = {\n\t__proto__: null,\n\tarea: true,\n\tbase: true,\n\tbasefont: true,\n\tbr: true,\n\tcol: true,\n\tframe: true,\n\thr: true,\n\timg: true,\n\tinput: true,\n\tisindex: true,\n\tlink: true,\n\tmeta: true,\n\tparam: true,\n\tembed: true\n};\n\nParser.prototype._processCloseTag = function(name){\n\tif(this._stack && (!(name in emptyTags) || this._options.xmlMode)){\n\t\tvar pos = this._stack.lastIndexOf(name);\n\t\tif(pos !== -1)\n\t\t\tif(this._cbs.onclosetag){\n\t\t\t\tpos = this._stack.length - pos;\n\t\t\t\twhile(pos--) this._cbs.onclosetag(this._stack.pop());\n\t\t\t}\n\t\t\telse this._stack.splice(pos);\n\t}\n\t//many browsers (eg. Safari, Chrome) convert </br> to <br>\n\telse if(name === \"br\" && !this._options.xmlMode){\n\t\tthis._processOpenTag(name + \"/\");\n\t}\n};\n\nParser.prototype._parseAttributes = function(data, lcNames){\n\tfor(var match; match = _reAttrib.exec(data);){\n\t\tthis._cbs.onattribute(lcNames ? match[1].toLowerCase() : match[1], match[2] || match[3] || match[4] || \"\");\n\t}\n};\n\n//parses the attribute string\nvar parseAttributes = function(data, lcNames){\n\tvar attrs = {};\n\tfor(var match; match = _reAttrib.exec(data);){\n\t\tattrs[lcNames ? match[1].toLowerCase() : match[1]] = match[2] || match[3] || match[4] || \"\";\n\t}\n\treturn attrs;\n};\n\nParser.prototype._processOpenTag = function(data){\n\tvar name = this._parseTagName(data),\n\t\tattributes = parseAttributes(data, this._options.lowerCaseAttributeNames),\n\t\ttype = ElementType.Tag;\n\t\n\tif(this._options.xmlMode){ /*do nothing*/ }\n\telse if(name === \"script\") type = ElementType.Script;\n\telse if(name === \"style\")  type = ElementType.Style;\n\tif (!this._options.xmlMode && name in openImpliesClose) {\n\t\tvar el;\n\t\twhile ((el = this._stack[this._stack.length-1]) in openImpliesClose[name]) {\n\t\t\tthis._processCloseTag(el);\n\t\t}\n\t}\n\tif(this._cbs.onopentagname) this._cbs.onopentagname(name);\n\tif(this._cbs.onopentag) this._cbs.onopentag(name, attributes);\n\tif(this._cbs.onattribute){\n\t\tthis._parseAttributes(data, this._options.lowerCaseAttributeNames);\n\t}\n\t\n\t//If tag self-terminates, add an explicit, separate closing tag\n\t/* http://dev.w3.org/html5/html-author/#tags\n\t * In XHTML, self-closing tags are valid but attribute values must be quoted.\n\t * In HTML, self-closing tags must be either void elements or foreign elements.\n\t * Invalid HTML self-closing tag syntax is ignored (treated as an opening tag).\n\t * Foreign elements use XML rules\n\t */\n\tif((!this._options.xmlMode && name in emptyTags) || (data.substr(-1) === \"/\" && data.replace(_reAttrib, \"\").substr(-1) === \"/\")){\n\t\tif(this._cbs.onclosetag) this._cbs.onclosetag(name);\n\t} else {\n\t\tif(type !== ElementType.Tag){\n\t\t\tthis._contentFlags |= SpecialTags[type];\n\t\t\tthis._wroteSpecial = false;\n\t\t}\n\t\tthis._stack.push(name);\n\t}\n};\n\nParser.prototype._handleError = function(error){\n\terror = new Error(error);\n\tif(this._cbs.onerror) this._cbs.onerror(error);\n\telse throw error;\n};\n\nmodule.exports = Parser;\n","//Types of elements found in the DOM\nmodule.exports = {\n\tText: 0, //Text\n\tDirective: 1, //<? ... ?>\n\tComment: 2, //<!-- ... -->\n\tScript: 3, //<script> tags\n\tStyle: 4, //<style> tags\n\tTag: 5, //Any tag\n\tCDATA: 6 //<![CDATA[ ... ]]>\n};","var index = require(\"./index.js\"),\n    DomHandler = index.DomHandler,\n\tDomUtils = index.DomUtils;\n\n//TODO: make this a streamable handler\nfunction FeedHandler(callback){\n\tthis.init(callback, { ignoreWhitespace: true });\n}\n\nrequire(\"util\").inherits(FeedHandler, DomHandler);\n\nFeedHandler.prototype.init = DomHandler;\n\nfunction getElements(what, where, one, recurse){\n\tif(one) return DomUtils.getElementsByTagName(what, where, recurse, 1)[0];\n\treturn DomUtils.getElementsByTagName(what, where, recurse);\n}\nfunction fetch(what, where, recurse){\n\tvar ret = DomUtils.getElementsByTagName(what, where, recurse, 1);\n\treturn ret.length > 0 && ret[0].children.length > 0 && ret[0].children[0].data;\n}\n\nvar isValidFeed = function(value) {\n\treturn value === \"rss\" || value === \"feed\" || value === \"rdf:RDF\";\n};\n\nFeedHandler.prototype.onend = function() {\n\tvar feed = {},\n\t\tfeedRoot = getElements(isValidFeed, this.dom, true),\n\t\ttmp, childs;\n\n\tif (feedRoot) {\n\t\tif(feedRoot.name === \"feed\"){\n\t\t\tchilds = feedRoot.children;\n\n\t\t\tfeed.type = \"atom\";\n\t\t\tif(tmp = fetch(\"id\", childs)) feed.id = tmp;\n\t\t\tif(tmp = fetch(\"title\", childs)) feed.title = tmp;\n\t\t\tif((tmp = getElements(\"link\", childs, true)) && (tmp = tmp.attribs) && (tmp = tmp.href)) feed.link = tmp;\n\t\t\tif(tmp = fetch(\"subtitle\", childs)) feed.description = tmp;\n\t\t\tif(tmp = fetch(\"updated\", childs)) feed.updated = new Date(tmp);\n\t\t\tif(tmp = fetch(\"email\", childs, true)) feed.author = tmp;\n\n\t\t\tfeed.items = getElements(\"entry\", childs).map(function(item){\n\t\t\t\tvar entry = {}, tmp;\n\n\t\t\t\titem = item.children;\n\n\t\t\t\tif(tmp = fetch(\"id\", item)) entry.id = tmp;\n\t\t\t\tif(tmp = fetch(\"title\", item)) entry.title = tmp;\n\t\t\t\tif((tmp = getElements(\"link\", item, true)) && (tmp = tmp.attribs) && (tmp = tmp.href)) entry.link = tmp;\n\t\t\t\tif(tmp = fetch(\"summary\", item)) entry.description = tmp;\n\t\t\t\tif(tmp = fetch(\"updated\", item)) entry.pubDate = new Date(tmp);\n\t\t\t\treturn entry;\n\t\t\t});\n\t\t} else{\n\t\t\tchilds = getElements(\"channel\", feedRoot.children, true).children;\n\n\t\t\tfeed.type = feedRoot.name.substr(0, 3);\n\t\t\tfeed.id = \"\";\n\t\t\tif(tmp = fetch(\"title\", childs)) feed.title = tmp;\n\t\t\tif(tmp = fetch(\"link\", childs)) feed.link = tmp;\n\t\t\tif(tmp = fetch(\"description\", childs)) feed.description = tmp;\n\t\t\tif(tmp = fetch(\"lastBuildDate\", childs)) feed.updated = new Date(tmp);\n\t\t\tif(tmp = fetch(\"managingEditor\", childs)) feed.author = tmp;\n\n\t\t\tfeed.items = getElements(\"item\", feedRoot.children).map(function(item){\n\t\t\t\tvar entry = {}, tmp;\n\n\t\t\t\titem = item.children;\n\n\t\t\t\tif(tmp = fetch(\"guid\", item)) entry.id = tmp;\n\t\t\t\tif(tmp = fetch(\"title\", item)) entry.title = tmp;\n\t\t\t\tif(tmp = fetch(\"link\", item)) entry.link = tmp;\n\t\t\t\tif(tmp = fetch(\"description\", item)) entry.description = tmp;\n\t\t\t\tif(tmp = fetch(\"pubDate\", item)) entry.pubDate = new Date(tmp);\n\t\t\t\treturn entry;\n\t\t\t});\n\t\t}\n\t}\n\tthis.dom = feed;\n\tDomHandler.prototype._handleCallback.call(\n\t\tthis, feedRoot ? null : Error(\"couldn't find root of feed\")\n\t);\n};\n\nmodule.exports = FeedHandler;","var WritableStream = require(\"./WritableStream.js\");\n\nvar Stream = function(options){\n\tWritableStream.call(this, new cbs(this), options);\n};\n\nrequire(\"util\").inherits(Stream, WritableStream);\n\nStream.prototype.readable = true;\n\nvar cbs = function(scope){\n\tthis.scope = scope;\n};\n\nvar EVENTS = require(\"../\").EVENTS;\n\nObject.keys(EVENTS).forEach(function(name){\n\tif(EVENTS[name] === 0){\n\t\tcbs.prototype[\"on\" + name] = function(){\n\t\t\tthis.scope.emit(name);\n\t\t};\n\t} else if(EVENTS[name] === 1){\n\t\tcbs.prototype[\"on\" + name] = function(a){\n\t\t\tthis.scope.emit(name, a);\n\t\t};\n\t} else if(EVENTS[name] === 2){\n\t\tcbs.prototype[\"on\" + name] = function(a, b){\n\t\t\tthis.scope.emit(name, a, b);\n\t\t};\n\t} else {\n\t\tthrow Error(\"wrong number of arguments!\");\n\t}\n});\n\nmodule.exports = Stream;","var Parser = require(\"./Parser.js\");\n\nvar WritableStream = function(cbs, options){\n\tParser.call(this, cbs, options);\n};\n\nrequire(\"util\").inherits(WritableStream, require(\"stream\").Stream);\n\n//util.inherits would overwrite the prototype when called twice,\n//so we need a different approach\nObject.getOwnPropertyNames(Parser.prototype).forEach(function(name){\n\tWritableStream.prototype[name] = Parser.prototype[name];\n});\n\nWritableStream.prototype.writable = true;\n\n// TODO improve support for Parser#pause and Parser#continue\n\nmodule.exports = WritableStream;","var WritableStream = require(\"./WritableStream.js\");\n\nvar Stream = function(options){\n\tWritableStream.call(this, new cbs(this), options);\n};\n\nrequire(\"util\").inherits(Stream, WritableStream);\n\nStream.prototype.readable = true;\n\nvar cbs = function(scope){\n\tthis.scope = scope;\n};\n\nvar EVENTS = require(\"../\").EVENTS;\n\nObject.keys(EVENTS).forEach(function(name){\n\tif(EVENTS[name] === 0){\n\t\tcbs.prototype[\"on\" + name] = function(){\n\t\t\tthis.scope.emit(name);\n\t\t};\n\t} else if(EVENTS[name] === 1){\n\t\tcbs.prototype[\"on\" + name] = function(a){\n\t\t\tthis.scope.emit(name, a);\n\t\t};\n\t} else if(EVENTS[name] === 2){\n\t\tcbs.prototype[\"on\" + name] = function(a, b){\n\t\t\tthis.scope.emit(name, a, b);\n\t\t};\n\t} else {\n\t\tthrow Error(\"wrong number of arguments!\");\n\t}\n});\n\nmodule.exports = Stream;","var ProxyHandler = function(cbs){\n\tif(cbs) this._cbs = cbs;\n};\n\nProxyHandler.prototype._cbs = {};\n\nObject.keys(require(\"./\").EVENTS).forEach(function(name){\n\tname = \"on\" + name;\n\tObject.defineProperty(ProxyHandler.prototype, name, {\n\t\tenumerable:true, configurable:true,\n\t\tget: function(){ return this._cbs[name]; },\n\t\tset: function(value){\n\t\t\t//allow functions to be overwritten\n\t\t\tObject.defineProperty(this, name, {value: value});\n\t\t}\n\t});\n});\n\nmodule.exports = ProxyHandler;"]}