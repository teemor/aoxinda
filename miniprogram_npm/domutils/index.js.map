{"version":3,"sources":["index.js","lib\\stringify.js","lib\\traversal.js","lib\\manipulation.js","lib\\querying.js","lib\\legacy.js","lib\\helpers.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,ACHA,AHSA,ACHA;AFOA,AGTA,ACHA,AHSA,ACHA;AFOA,AGTA,ACHA,AHSA,ACHA;AGRA,AFMA,ACHA,AHSA,ACHA;AGRA,AFMA,ACHA,AHSA,ACHA;AGRA,AFMA,ACHA,AHSA,ACHA;AIXA,ADGA,AFMA,ACHA,AHSA,ACHA;AIXA,ADGA,AFMA,ACHA,AHSA,ACHA;AIXA,ADGA,AFMA,ACHA,AHSA,ACHA;AIXA,ADGA,AFMA,ACHA,AHSA,ACHA;AIXA,ADGA,AFMA,ACHA,AHSA,ACHA;AIXA,ADGA,AFMA,ACHA,AHSA,ACHA;AIXA,ADGA,AFMA,ACHA,AHSA,ACHA;AIXA,ADGA,AFMA,ACHA,AHSA,ACHA;AIXA,ADGA,AFMA,ACHA,AHSA,ACHA;AIXA,ADGA,AFMA,ACHA,AHSA,ACHA;AIXA,ADGA,AFMA,ACHA,AHSA,ACHA;AIXA,ADGA,AFMA,ACHA,AHSA,ACHA;AIXA,ADGA,AFMA,ACHA,AHSA,ACHA;AIXA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AKdA,ADGA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var DomUtils = module.exports;\n\n[\n\trequire(\"./lib/stringify\"),\n\trequire(\"./lib/traversal\"),\n\trequire(\"./lib/manipulation\"),\n\trequire(\"./lib/querying\"),\n\trequire(\"./lib/legacy\"),\n\trequire(\"./lib/helpers\")\n].forEach(function(ext){\n\tObject.keys(ext).forEach(function(key){\n\t\tDomUtils[key] = ext[key].bind(DomUtils);\n\t});\n});\n","var ElementType = require(\"domelementtype\"),\n    isTag = ElementType.isTag;\n\nmodule.exports = {\n\tgetInnerHTML: getInnerHTML,\n\tgetOuterHTML: getOuterHTML,\n\tgetText: getText\n};\n\nfunction getInnerHTML(elem){\n\treturn elem.children ? elem.children.map(getOuterHTML).join(\"\") : \"\";\n}\n\n//boolean attributes without a value (taken from MatthewMueller/cheerio)\nvar booleanAttribs = {\n\t__proto__: null,\n\tasync: true,\n\tautofocus: true,\n\tautoplay: true,\n\tchecked: true,\n\tcontrols: true,\n\tdefer: true,\n\tdisabled: true,\n\thidden: true,\n\tloop: true,\n\tmultiple: true,\n\topen: true,\n\treadonly: true,\n\trequired: true,\n\tscoped: true,\n\tselected: true\n};\n\nvar emptyTags = {\n\t__proto__: null,\n\tarea: true,\n\tbase: true,\n\tbasefont: true,\n\tbr: true,\n\tcol: true,\n\tframe: true,\n\thr: true,\n\timg: true,\n\tinput: true,\n\tisindex: true,\n\tlink: true,\n\tmeta: true,\n\tparam: true,\n\tembed: true\n};\n\nfunction getOuterHTML(elem){\n\tswitch(elem.type){\n\tcase ElementType.Text:\n\t\treturn elem.data;\n\tcase ElementType.Comment:\n\t\treturn \"<!--\" + elem.data + \"-->\";\n\tcase ElementType.Directive:\n\t\treturn \"<\" + elem.data + \">\";\n\tcase ElementType.CDATA:\n\t\treturn \"<!CDATA \" + getInnerHTML(elem) + \"]]>\";\n\t}\n\n\tvar ret = \"<\" + elem.name;\n\tif(\"attribs\" in elem){\n\t\tfor(var attr in elem.attribs){\n\t\t\tif(elem.attribs.hasOwnProperty(attr)){\n\t\t\t\tret += \" \" + attr;\n\t\t\t\tvar value = elem.attribs[attr];\n\t\t\t\tif(value == null){\n\t\t\t\t\tif( !(attr in booleanAttribs) ){\n\t\t\t\t\t\tret += \"=\\\"\\\"\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tret += \"=\\\"\" + value + \"\\\"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (elem.name in emptyTags && elem.children.length === 0) {\n\t\treturn ret + \" />\";\n\t} else {\n\t\treturn ret + \">\" + getInnerHTML(elem) + \"</\" + elem.name + \">\";\n\t}\n}\n\nfunction getText(elem){\n\tif(Array.isArray(elem)) return elem.map(getText).join(\"\");\n\tif(isTag(elem) || elem.type === ElementType.CDATA) return getText(elem.children);\n\tif(elem.type === ElementType.Text) return elem.data;\n\treturn \"\";\n}","var getChildren = exports.getChildren = function(elem){\n\treturn elem.children;\n};\n\nvar getParent = exports.getParent = function(elem){\n\treturn elem.parent;\n};\n\nexports.getSiblings = function(elem){\n\tvar parent = getParent(elem);\n\treturn parent ? getChildren(parent) : [elem];\n};\n\nexports.getAttributeValue = function(elem, name){\n\treturn elem.attribs && elem.attribs[name];\n};\n\nexports.hasAttrib = function(elem, name){\n\treturn hasOwnProperty.call(elem.attribs, name);\n};\n\nexports.getName = function(elem){\n\treturn elem.name;\n};\n","exports.removeElement = function(elem){\n\tif(elem.prev) elem.prev.next = elem.next;\n\tif(elem.next) elem.next.prev = elem.prev;\n\n\tif(elem.parent){\n\t\tvar childs = elem.parent.children;\n\t\tchilds.splice(childs.lastIndexOf(elem), 1);\n\t}\n};\n\nexports.replaceElement = function(elem, replacement){\n\tvar prev = replacement.prev = elem.prev;\n\tif(prev){\n\t\tprev.next = replacement;\n\t}\n\n\tvar next = replacement.next = elem.next;\n\tif(next){\n\t\tnext.prev = replacement;\n\t}\n\n\tvar parent = replacement.parent = elem.parent;\n\tif(parent){\n\t\tvar childs = parent.children;\n\t\tchilds[childs.lastIndexOf(elem)] = replacement;\n\t}\n};\n\nexports.appendChild = function(elem, child){\n\tchild.parent = elem;\n\n\tif(elem.children.push(child) !== 1){\n\t\tvar sibling = elem.children[elem.children.length - 2];\n\t\tsibling.next = child;\n\t\tchild.prev = sibling;\n\t\tchild.next = null;\n\t}\n};\n\nexports.append = function(elem, next){\n\tvar parent = elem.parent,\n\t\tcurrNext = elem.next;\n\n\tnext.next = currNext;\n\tnext.prev = elem;\n\telem.next = next;\n\tnext.parent = parent;\n\n\tif(currNext){\n\t\tcurrNext.prev = next;\n\t\tif(parent){\n\t\t\tvar childs = parent.children;\n\t\t\tchilds.splice(childs.lastIndexOf(currNext), 0, next);\n\t\t}\n\t} else if(parent){\n\t\tparent.children.push(next);\n\t}\n};\n\nexports.prepend = function(elem, prev){\n\tvar parent = elem.parent;\n\tif(parent){\n\t\tvar childs = parent.children;\n\t\tchilds.splice(childs.lastIndexOf(elem), 0, prev);\n\t}\n\n\tif(elem.prev){\n\t\telem.prev.next = prev;\n\t}\n\t\n\tprev.parent = parent;\n\tprev.prev = elem.prev;\n\tprev.next = elem;\n\telem.prev = prev;\n};\n\n\n","var isTag = require(\"domelementtype\").isTag;\n\nmodule.exports = {\n\tfilter: filter,\n\tfind: find,\n\tfindOneChild: findOneChild,\n\tfindOne: findOne,\n\texistsOne: existsOne,\n\tfindAll: findAll\n};\n\nfunction filter(test, element, recurse, limit){\n\tif(!Array.isArray(element)) element = [element];\n\n\tif(typeof limit !== \"number\" || !isFinite(limit)){\n\t\tlimit = Infinity;\n\t}\n\treturn find(test, element, recurse !== false, limit);\n}\n\nfunction find(test, elems, recurse, limit){\n\tvar result = [], childs;\n\n\tfor(var i = 0, j = elems.length; i < j; i++){\n\t\tif(test(elems[i])){\n\t\t\tresult.push(elems[i]);\n\t\t\tif(--limit <= 0) break;\n\t\t}\n\n\t\tchilds = elems[i].children;\n\t\tif(recurse && childs && childs.length > 0){\n\t\t\tchilds = find(test, childs, recurse, limit);\n\t\t\tresult = result.concat(childs);\n\t\t\tlimit -= childs.length;\n\t\t\tif(limit <= 0) break;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction findOneChild(test, elems){\n\tfor(var i = 0, l = elems.length; i < l; i++){\n\t\tif(test(elems[i])) return elems[i];\n\t}\n\n\treturn null;\n}\n\nfunction findOne(test, elems){\n\tvar elem = null;\n\n\tfor(var i = 0, l = elems.length; i < l && !elem; i++){\n\t\tif(!isTag(elems[i])){\n\t\t\tcontinue;\n\t\t} else if(test(elems[i])){\n\t\t\telem = elems[i];\n\t\t} else if(elems[i].children.length > 0){\n\t\t\telem = findOne(test, elems[i].children);\n\t\t}\n\t}\n\n\treturn elem;\n}\n\nfunction existsOne(test, elems){\n\tfor(var i = 0, l = elems.length; i < l; i++){\n\t\tif(\n\t\t\tisTag(elems[i]) && (\n\t\t\t\ttest(elems[i]) || (\n\t\t\t\t\telems[i].children.length > 0 &&\n\t\t\t\t\texistsOne(test, elems[i].children)\n\t\t\t\t)\n\t\t\t)\n\t\t){\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nfunction findAll(test, elems){\n\tvar result = [];\n\tfor(var i = 0, j = elems.length; i < j; i++){\n\t\tif(!isTag(elems[i])) continue;\n\t\tif(test(elems[i])) result.push(elems[i]);\n\n\t\tif(elems[i].children.length > 0){\n\t\t\tresult = result.concat(findAll(test, elems[i].children));\n\t\t}\n\t}\n\treturn result;\n}\n","var ElementType = require(\"domelementtype\");\nvar isTag = exports.isTag = ElementType.isTag;\n\nexports.testElement = function(options, element){\n\tfor(var key in options){\n\t\tif(!options.hasOwnProperty(key));\n\t\telse if(key === \"tag_name\"){\n\t\t\tif(!isTag(element) || !options.tag_name(element.name)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if(key === \"tag_type\"){\n\t\t\tif(!options.tag_type(element.type)) return false;\n\t\t} else if(key === \"tag_contains\"){\n\t\t\tif(isTag(element) || !options.tag_contains(element.data)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if(!element.attribs || !options[key](element.attribs[key])){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\n\nvar Checks = {\n\ttag_name: function(name){\n\t\tif(typeof name === \"function\"){\n\t\t\treturn function(elem){ return isTag(elem) && name(elem.name); };\n\t\t} else if(name === \"*\"){\n\t\t\treturn isTag;\n\t\t} else {\n\t\t\treturn function(elem){ return isTag(elem) && elem.name === name; };\n\t\t}\n\t},\n\ttag_type: function(type){\n\t\tif(typeof type === \"function\"){\n\t\t\treturn function(elem){ return type(elem.type); };\n\t\t} else {\n\t\t\treturn function(elem){ return elem.type === type; };\n\t\t}\n\t},\n\ttag_contains: function(data){\n\t\tif(typeof data === \"function\"){\n\t\t\treturn function(elem){ return !isTag(elem) && data(elem.data); };\n\t\t} else {\n\t\t\treturn function(elem){ return !isTag(elem) && elem.data === data; };\n\t\t}\n\t}\n};\n\nfunction getAttribCheck(attrib, value){\n\tif(typeof value === \"function\"){\n\t\treturn function(elem){ return elem.attribs && value(elem.attribs[attrib]); };\n\t} else {\n\t\treturn function(elem){ return elem.attribs && elem.attribs[attrib] === value; };\n\t}\n}\n\nfunction combineFuncs(a, b){\n\treturn function(elem){\n\t\treturn a(elem) || b(elem);\n\t};\n}\n\nexports.getElements = function(options, element, recurse, limit){\n\tvar funcs = Object.keys(options).map(function(key){\n\t\tvar value = options[key];\n\t\treturn key in Checks ? Checks[key](value) : getAttribCheck(key, value);\n\t});\n\n\treturn funcs.length === 0 ? [] : this.filter(\n\t\tfuncs.reduce(combineFuncs),\n\t\telement, recurse, limit\n\t);\n};\n\nexports.getElementById = function(id, element, recurse){\n\tif(!Array.isArray(element)) element = [element];\n\treturn this.findOne(getAttribCheck(\"id\", id), element, recurse !== false);\n};\n\nexports.getElementsByTagName = function(name, element, recurse, limit){\n\treturn this.filter(Checks.tag_name(name), element, recurse, limit);\n};\n\nexports.getElementsByTagType = function(type, element, recurse, limit){\n\treturn this.filter(Checks.tag_type(type), element, recurse, limit);\n};\n","// removeSubsets\n// Given an array of nodes, remove any member that is contained by another.\nexports.removeSubsets = function(nodes) {\n\tvar idx = nodes.length, node, ancestor, replace;\n\n\t// Check if each node (or one of its ancestors) is already contained in the\n\t// array.\n\twhile (--idx > -1) {\n\t\tnode = ancestor = nodes[idx];\n\n\t\t// Temporarily remove the node under consideration\n\t\tnodes[idx] = null;\n\t\treplace = true;\n\n\t\twhile (ancestor) {\n\t\t\tif (nodes.indexOf(ancestor) > -1) {\n\t\t\t\treplace = false;\n\t\t\t\tnodes.splice(idx, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tancestor = ancestor.parent;\n\t\t}\n\n\t\t// If the node has been found to be unique, re-insert it.\n\t\tif (replace) {\n\t\t\tnodes[idx] = node;\n\t\t}\n\t}\n\n\treturn nodes;\n};\n"]}